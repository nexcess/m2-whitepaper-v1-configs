#---------------------------------------------------------------
# Core ModSecurity Rule Set ver.2.2.9
# Copyright (C) 2006-2012 Trustwave All rights reserved.
#
# The OWASP ModSecurity Core Rule Set is distributed under 
# Apache Software License (ASL) version 2
# Please see the enclosed LICENCE file for full details.
# ---------------------------------------------------------------

#
# This is a modified version of the experimental brute force detection rules
# from the OWASP CRS project. Rather than only looking at the number of requests sent to a particular
# URL, these rules intead look at the URL, HTTP status, and headers returned by Wordpress and
# Magento in order to determine whether a failed login has taken place. Most CMS's will redirect
# you on a succesful login.
#
# If so, it increments long and short brute force counters, which look at how many failed logins
# have taken place over different time periods. Attackers are frequently attempting slow brute force
# attacks against multiple websites at the same time, which gets around many brute force protection systems.
#
# The number of failed logins permitted within a given period of time before blocking an IP are configured
# in modsecurity_crs_10_setup.conf
#
#
## Quick reference of return statuses given by Magento and Wordpress logins, and what versions were tested:
#
# Wordpress Backend (3.x -> 4.3)
#   Success: 302   Failure: 200
#
# Magento Backend (1.4 -> 1.9)
#   Success: 302   Failure: 200
#
# Magento Connect (1.4 & 1.5)
#   Success: 302   Failure: 200
#
# Magento Connect (1.6 -> 1.9)
#   Success: 200   Failure: 302
#


#
# Exclude IP addresses placed in modsecurity_crs_11_brute_force_ip_wl.conf
# from being blocked by the brute force ruleset.
#
SecRule REMOTE_ADDR "@ipMatchFromFile modsecurity_crs_11_brute_force_ip_wl.data" \
    "phase:1,\
    id:4011017,\
    pass,\
    nolog,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS"

#
# Enforce an existing IP address block and log only 1-time/minute
# We don't want to get flooded by alerts during an attack or scan so
# we are only triggering an alert once/minute.  You can adjust how often
# you want to receive status alerts by changing the expirevar setting below.
#
SecRule IP:BRUTE_FORCE_BLOCK "@eq 1" \
    "chain,\
    phase:1,\
    id:'4011000',\
    tag:'NEXCESS/BRUTE_FORCE',\
    deny,\
    msg:'Brute Force Attack Identified from %{tx.real_ip} (%{tx.brute_force_block_counter} hits since last alert)',\
    setvar:ip.brute_force_block_counter=+1"
        SecRule &IP:BRUTE_FORCE_BLOCK_FLAG "@eq 0" \
            "setvar:ip.brute_force_block_flag=1,\
            expirevar:ip.brute_force_block_flag=60,\
            setvar:tx.brute_force_block_counter=%{ip.brute_force_block_counter},\
            setvar:ip.brute_force_block_counter=0"

#
# Block and track # of requests but don't log
#
SecRule IP:BRUTE_FORCE_BLOCK "@eq 1" \
    "phase:1,\
    id:'4011001',\
    tag:'NEXCESS/BRUTE_FORCE',\
    deny,\
    nolog"

# 
# Same as above, but looking at failed logins within past 60 minutes.
# 
SecRule IP:LONG_BRUTE_FORCE_BLOCK "@eq 1" \
    "chain,\
    phase:1,\
    id:'4011002',\
    tag:'NEXCESS/BRUTE_FORCE',\
    deny,\
    msg:'LONG Brute Force Attack Identified from %{tx.real_ip} (%{tx.long_brute_force_block_counter} hits since last alert)',\
    setvar:ip.long_brute_force_block_counter=+1"
        SecRule &IP:LONG_BRUTE_FORCE_BLOCK_FLAG "@eq 0" \
            "setvar:ip.long_brute_force_block_flag=1,\
            expirevar:ip.long_brute_force_block_flag=60,\
            setvar:tx.long_brute_force_block_counter=%{ip.long_brute_force_block_counter},\
            setvar:ip.long_brute_force_block_counter=0"

#
# Block and track # of requests but don't log
#
SecRule IP:LONG_BRUTE_FORCE_BLOCK "@eq 1" \
    "phase:1,\
    id:'4011003',\
    tag:'NEXCESS/BRUTE_FORCE',\
    deny,\
    nolog"

#
# skipAfter Checks
# There are different scenarios where we don't want to do checks -
#
# Avoid blocking the server's own IP in cases where there might not be an
# X-Fowarded-For header set for something like Varnish
SecRule REMOTE_ADDR "127\.0\.0\.1|%{SERVER_ADDR}" \
    "phase:5,\
    id:'4011016',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS,\
    chain"
        SecRule &REQUEST_HEADERS:x-forwarded-for "@eq 0" "chain"
		SecRule &REQUEST_HEADERS:x-client-ip "@eq 0"
# The current URL is not a protected URL
SecRule REQUEST_URI "!@pm /wp-login.php /xmlrpc.php /index.php /downloader/" \
    "phase:5,\
    id:'4011004',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS"
# The request does not contain a request body with any content. We are only checking login requests
#   that should be done in a POST request, so no need to check anything with no request body.
SecRule REQUEST_BODY_LENGTH "@le 0" \
    "phase:5,\
    id:'4011005',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS"
# The current IP address is currently being blocked due after reaching a brute
# force threshold, so there is no need to continue checking requests from that IP
SecRule IP:BRUTE_FORCE_BLOCK "@eq 1" \
    "phase:5,\
    id:'4011006',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS"
# Magento Connect Manager gives a different return status on failed logins after Magento 1.6,
# so we have to add a skipafter check and look at the Location header returned by Magento
# to avoid breaking Magento Connect logins on newer Magento verions(regular magento backend 
# logins are more consistent)
SecRule REQUEST_URI "/downloader/" \
    "phase:5,\
    id:'4011007',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    skipAfter:END_BRUTE_FORCE_PROTECTION_CHECKS,\
    chain"
        SecRule ARGS_POST_NAMES "username" "t:urldecode,chain"
            SecRule ARGS_POST_NAMES "password" "chain" 
                SecRule RESPONSE_STATUS "200" "chain"
                    SecRule RESPONSE_HEADERS:Set-Cookie "PHPSESSID=deleted"

#
# Brute Force Signatures
# 
# Magento Connect Manager failed login - versions < 1.6
SecRule REQUEST_URI "/downloader/" \
    "phase:5,\
    id:'4011008',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    chain"
        SecRule ARGS_POST_NAMES "username" "t:urldecode,chain"
            SecRule ARGS_POST_NAMES "password" "chain" 
                SecRule RESPONSE_STATUS "200" \
                    "setvar:ip.brute_force_counter=+1,\
                    setvar:ip.long_brute_force_counter=+1"
# Magento Connect Manager failed login - versions >= 1.6
SecRule REQUEST_URI "/downloader/" \
    "phase:5,\
    id:'4011009',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    chain"
        SecRule ARGS_POST_NAMES "username" "t:urldecode,chain"
            SecRule ARGS_POST_NAMES "password" "chain" 
                SecRule RESPONSE_STATUS "302" "chain"
                    SecRule RESPONSE_HEADERS:Location "/downloader/index.php\?A=loggedin" \
                        "setvar:ip.brute_force_counter=+1,\
                        setvar:ip.long_brute_force_counter=+1"
# Magento Backend failed login
# Check the set-cookie value here is not done to determine whether the login 
# was successful, but rather to just make the signature more specific as
# index.php is a somewhat of a common url..
SecRule REQUEST_URI "/index.php" \
    "phase:5,\
    id:'4011010',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    t:urldecode,\
    nolog,\
    pass,\
    chain"
        SecRule ARGS_POST_NAMES "login\[username\]" "chain"
            SecRule ARGS_POST_NAMES "login\[password\]" "chain" 
                SecRule RESPONSE_STATUS "200" "chain"
                    SecRule RESPONSE_HEADERS:Set-Cookie "adminhtml=.+?;\sexpires=.+?;\spath=.+?;\sdomain=.+?;\s(?i)httponly" \
                            "setvar:ip.brute_force_counter=+1,\
                            setvar:ip.long_brute_force_counter=+1"
# Wordpress pingback reflective DoS
SecRule REQUEST_URI "/xmlrpc.php" \
    "phase:5,\
    id:'4011011',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    chain"
        SecRule STREAM_INPUT_BODY "pingback" \
            "setvar:ip.brute_force_counter=+1,\
            setvar:ip.long_brute_force_counter=+1"
# Wordpress failed login
SecRule REQUEST_URI "/wp-login.php" \
    "phase:5,\
    id:'4011012',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    chain"
        SecRule ARGS_POST_NAMES "log" "chain"
            SecRule ARGS_POST_NAMES "pwd" "chain"
                SecRule RESPONSE_STATUS "200" \
                    "setvar:ip.brute_force_counter=+1,\
                    setvar:ip.long_brute_force_counter=+1"

#
# Check Brute Force Counter
# If the request count is greater than or equal to 50 within 5 mins,
# we then set the burst counter
# 
SecRule IP:BRUTE_FORCE_COUNTER "@ge %{tx.brute_force_counter_threshold}" \
    "phase:5,\
    id:'4011013',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    nolog,\
    pass,\
    t:none,\
    setvar:ip.brute_force_burst_counter=+1,\
    expirevar:ip.brute_force_burst_counter=%{tx.brute_force_burst_time_slice},\
    setvar:!ip.brute_force_counter"

#
# Check Brute Force Burst Counter and set Block
# Check the burst counter - if greater than or equal to 2, then we set the IP
# block variable for 10 minutes and issue an alert.
#
SecRule IP:BRUTE_FORCE_BURST_COUNTER "@ge 2" \
    "phase:5,\
    id:'4011014',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    log,\
    pass,\
    msg:'Potential Brute Force Attack from %{tx.real_ip}, setting brute_force_block_flag - # of Request Bursts: %{ip.brute_force_burst_counter}',\
    setvar:ip.brute_force_block=1,\
    expirevar:ip.brute_force_block=%{tx.brute_force_block_timeout}"

#
# Check Long Brute Force Counter - if greater than or equal to 30, 
# set IP block variable for two hours.
#
SecRule IP:LONG_BRUTE_FORCE_COUNTER "@ge %{tx.long_brute_force_counter_threshold}" \
    "phase:5,\
    id:'4011015',\
    tag:'NEXCESS/BRUTE_FORCE',\
    t:none,\
    log,\
    pass,\
    msg:'Potential LONG Brute Force Attack from %{tx.real_ip}, setting long_brute_force_block flag',\
    setvar:ip.long_brute_force_block=1,\
    expirevar:ip.long_brute_force_block=%{tx.long_brute_force_block_timeout},\
    setvar:!ip.long_brute_force_counter"


SecMarker END_BRUTE_FORCE_PROTECTION_CHECKS
